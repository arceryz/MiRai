// We require version 430 since it supports compute shaders.
#version 430

// This is the workgroup size. The largest size that is guaranteed by OpenGL 
// to available is 1024, beyond this is uncertain.
// Might influence performance but only in advanced cases.
layout(local_size_x = 1024, local_size_y = 1, local_size_z = 1) in;

// Two buffers are here.
// The ray ssbo is packed per bounce, ie numPoints * numBounces.
layout(std430, binding=0) buffer pointSSBO {  vec2 points[]; };
layout(std430, binding=1) buffer distanceSSBO { float distances[]; };

layout(location=0) uniform int numRays;
layout(location=1) uniform int numBounces;
layout(location=2) uniform int numPoints;
layout(location=3) uniform float arcFocus;

const float PI = 3.14159;
const float STEP_MIN = 0.0001;
const float ARC_FOCUS_INF = 1000.0f;

struct HitInfo {
    float t;
    vec2 point;
    vec2 normal;
};
HitInfo RayLineHit(vec2 o, vec2 d, vec2 u, vec2 v);
HitInfo RayCircleHit(vec2 o, vec2 d, vec2 cc, float rsq, bool convex);

void main()
{
    // Index represents the point that we are casting.
    // This ranges from 0 to numRays.
    // We write distances for each particle at the numBounces consecutive positions.
    // That way we have multiple depth layers.
    uint index = gl_GlobalInvocationID.x;
    float prog = float(index) / numRays;

    // Ray originate from (0, 0).
    vec2 ray;
    ray.x = cos(2*PI*prog);
    ray.y = sin(2*PI*prog);

    vec2 origin = vec2(0);

    // Trace all bounces and store the distance at each collision.
    float travelled = 0;
    for (int i = 0; i < numBounces; i++) {
        HitInfo hitmin;
        hitmin.t = -1;

        // Evaluate every mirror plane.
        for (int j = 0; j < numPoints; j++) {
            vec2 u = points[j];
            vec2 v = points[(j+1)%numPoints];

            HitInfo hit;
            if (abs(arcFocus) < ARC_FOCUS_INF) {
                vec2 n = normalize(vec2(-v.y+u.y, v.x-u.x));
                vec2 arc = (u+v)/2 + n * arcFocus;
                float rsq = dot(arc-u, arc-u);
                hit = RayCircleHit(origin, ray, arc, rsq, arcFocus >= 0);
            }
            else {
                hit = RayLineHit(origin, ray, u, v);
            }
            
            if (hit.t > STEP_MIN && (hitmin.t < 0 || hit.t < hitmin.t)) {
                hitmin = hit;
            }
        }

        // Reflect.
        ray = ray - 2*hitmin.normal*dot(hitmin.normal, ray);
        origin = hitmin.point;
        travelled += hitmin.t;

        // Write at bounce dependent index.
        // If numbounces changes, then the stride grows with it.
        distances[index*numBounces+i] = travelled;
    }

}

// This function collides a ray o+td with a line uv.
HitInfo RayLineHit(vec2 o, vec2 d, vec2 u, vec2 v) 
{
    // The normal is a left-rotated vector.
    vec2 n = normalize(vec2(-v.y+u.y, v.x-u.x));
    float nd = dot(n, d);

    // We ensure that the dotproduct can't be zero
    // by adding a small factor when its zero.
    float t = dot(n, u-o) / (nd + float(nd==0)*0.001);

    HitInfo hit;
    hit.point = o + t*d;
    hit.normal = n;
    hit.t = t;
    return hit;
}

HitInfo RayCircleHit(vec2 o, vec2 d, vec2 cc, float rsq, bool convex)
{
    // Make the point relative to the circle.
    vec2 rel = o-cc;

    float a = dot(d, d);
    float b = 2*dot(rel, d);
    float c = dot(rel, rel) - rsq;
    float D = b*b - 4*a*c;

    // We take an absolute value here, but if the
    // square root ends up negative we set t to zero.
    float sqrtD = sqrt(abs(D));
    float t1 = (-b - sqrtD) / (2*a);
    float t2 = (-b + sqrtD) / (2*a);

    float t = float(convex)*max(t1, t2) + (1-float(convex))*min(t1, t2);

    HitInfo hit;
    hit.point = o + t*d;
    hit.normal = normalize(cc - hit.point);
    hit.t = t * float(D > 0);
    return hit;
}